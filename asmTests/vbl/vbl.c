// Generated by asm2c https://github.com/frranck/asm2c
#include "vbl.h"
#pragma GCC diagnostic ignored "-Woverlength-strings"
#pragma GCC diagnostic ignored "-Wunused-label"

Memory m = {
	{{0}},{{0}},{{0}},{{0}},{{0}},{{0}},{{0}},{{0}},{{0}},{{0}},{{0}},{{0}},{{0}},{{0}}, // registers
	0,0,0,0,0,0, //flags
	0, //isLittle
	0, //exitCode
	{0,0,0,0,0,21,0,0,42,0,0,63,9,0,0,9}, //pal_jeu
	{0,21,9,0,42,9,0,63,18,0,0,18,0,21,18,0}, //dummy1
	{42,18,0,63,27,0,0,27,0,21,27,0,42,27,0,63}, //dummy2
	{36,0,0,36,0,21,36,0,42,36,0,63,45,0,0,45}, //dummy3
	{0,21,45,0,42,45,0,63,54,0,0,54,0,21,54,0}, //dummy4
	{42,54,0,63,63,0,0,63,0,21,63,0,42,63,0,63}, //dummy5
	{0,9,0,0,9,21,0,9,42,0,9,63,9,9,0,9}, //dummy6
	{9,21,9,9,42,9,9,63,18,9,0,18,9,21,18,9}, //dummy7
	{42,18,9,63,27,9,0,27,9,21,27,9,42,27,9,63}, //dummy8
	{36,9,0,36,9,21,36,9,42,36,9,63,45,9,0,45}, //dummy9
	{9,21,45,9,42,45,9,63,54,9,0,54,9,21,54,9}, //dummy10
	{42,54,9,63,63,9,0,63,9,21,63,9,42,63,9,63}, //dummy11
	{0,18,0,0,18,21,0,18,42,0,18,63,9,18,0,9}, //dummy12
	{18,21,9,18,42,9,18,63,18,18,0,18,18,21,18,18}, //dummy13
	{42,18,18,63,27,18,0,27,18,21,27,18,42,27,18,63}, //dummy14
	{36,18,0,36,18,21,36,18,42,36,18,63,45,18,0,45}, //dummy15
	{18,21,45,18,42,45,18,63,54,18,0,54,18,21,54,18}, //dummy16
	{42,54,18,63,63,18,0,63,18,21,63,18,42,63,18,63}, //dummy17
	{0,27,0,0,27,21,0,27,42,0,27,63,9,27,0,9}, //dummy18
	{27,21,9,27,42,9,27,63,18,27,0,18,27,21,18,27}, //dummy19
	{42,18,27,63,27,27,0,27,27,21,27,27,42,27,27,63}, //dummy20
	{36,27,0,36,27,21,36,27,42,36,27,63,45,27,0,45}, //dummy21
	{27,21,45,27,42,45,27,63,54,27,0,54,27,21,54,27}, //dummy22
	{42,54,27,63,63,27,0,63,27,21,63,27,42,63,27,63}, //dummy23
	{0,36,0,0,36,21,0,36,42,0,36,63,9,36,0,9}, //dummy24
	{36,21,9,36,42,9,36,63,18,36,0,18,36,21,18,36}, //dummy25
	{42,18,36,63,27,36,0,27,36,21,27,36,42,27,36,63}, //dummy26
	{36,36,0,36,36,21,36,36,42,36,36,63,45,36,0,45}, //dummy27
	{36,21,45,36,42,45,36,63,54,36,0,54,36,21,54,36}, //dummy28
	{42,54,36,63,63,36,0,63,36,21,63,36,42,63,36,63}, //dummy29
	{0,45,0,0,45,21,0,45,42,0,45,63,9,45,0,9}, //dummy30
	{45,21,9,45,42,9,45,63,18,45,0,18,45,21,18,45}, //dummy31
	{42,18,45,63,27,45,0,27,45,21,27,45,42,27,45,63}, //dummy32
	{36,45,0,36,45,21,36,45,42,36,45,63,45,45,0,45}, //dummy33
	{45,21,45,45,42,45,45,63,54,45,0,54,45,21,54,45}, //dummy34
	{42,54,45,63,63,45,0,63,45,21,63,45,42,63,45,63}, //dummy35
	{0,54,0,0,54,21,0,54,42,0,54,63,9,54,0,9}, //dummy36
	{54,21,9,54,42,9,54,63,18,54,0,18,54,21,18,54}, //dummy37
	{42,18,54,63,27,54,0,27,54,21,27,54,42,27,54,63}, //dummy38
	{36,54,0,36,54,21,36,54,42,36,54,63,45,54,0,45}, //dummy39
	{54,21,45,54,42,45,54,63,54,54,0,54,54,21,54,54}, //dummy40
	{42,54,54,63,63,54,0,63,54,21,63,54,42,63,54,63}, //dummy41
	{0,63,0,0,63,21,0,63,42,0,63,63,9,63,0,9}, //dummy42
	{63,21,9,63,42,9,63,63,18,63,0,18,63,21,18,63}, //dummy43
	{42,18,63,63,27,63,0,27,63,21,27,63,42,27,63,63}, //dummy44
	{36,63,0,36,63,21,36,63,42,36,63,63,45,63,0,45}, //dummy45
	{63,21,45,63,42,45,63,63,54,63,0,54,63,21,54,63}, //dummy46
	{42,54,63,63,63,63,0,63,63,21,63,63,42,63,63,63}, //dummy47
	{0}, //dummy48

	{0}, //vgaPalette
	1,{0}, //selectorsPointer+selectors
	0,{0}, //stackPointer+stack
	0, //heapPointer
	{0}, //heap
	{0},{0},{0}, NULL
};

int program() {
	jmp_buf jmpbuffer;
	void * dest;
	void * src;
	int i;
#ifdef INCLUDEMAIN
	dest=NULL; src=NULL; i=0; //to avoid a warning.
#endif
	if (m.executionFinished) goto moveToBackGround;
	if (m.jumpToBackGround) {
		m.jumpToBackGround = 0;
#ifdef MRBOOM
		if (m.nosetjmp) m.stackPointer=0; // this an an hack to avoid setJmp in saved state.
		if (m.nosetjmp==2) goto directjeu;
		if (m.nosetjmp==1) goto directmenu;
#endif
		RET;
	}
	R(MOV(16,READDW(eax),16,(dw)19));
	R(INT(16));
	CALL(affpal);
	R(MOV(32,READDD(ebx),32,(dd)40960));
	R(MOV(16,READDW(eax),16,(dw)2));
	R(INT(49));
	R(MOV(16,READDW(es),16,(dw)READDW(eax)));
	R(XOR(32,READDD(edi),32,(dd)READDD(edi)));
	R(MOV(32,READDD(eax),32,(dd)2007695104));
	R(MOV(32,READDD(ecx),32,(dd)((320*200)/4)));
	R(REP_STOSD);
	R(MOV(32,*((dd *) realAddress(((20*320)+160), es)),32,(dd)2007695104));
	R(MOV(32,*((dd *) realAddress(0, es)),32,(dd)2007695104));
	R(MOV(16,READDW(edx),16,(dw)986));
arobasevbl12:
	IN(READDBl(eax),READDW(edx));
	R(TEST(8,READDBl(eax),8,(db)8));
	R(JNE(arobasevbl12));
arobasevbl22:
	IN(READDBl(eax),READDW(edx));
	R(TEST(8,READDBl(eax),8,(db)8));
	R(JE(arobasevbl22));
	R(MOV(16,READDW(edx),16,(dw)968));
	R(MOV(8,READDBl(eax),8,(db)0));
	OUT(READDW(edx),READDBl(eax));
	R(MOV(32,READDD(ecx),32,(dd)60));
dffd:
	R(MOV(16,READDW(edx),16,(dw)986));
arobasevbl1:
	IN(READDBl(eax),READDW(edx));
	R(TEST(8,READDBl(eax),8,(db)8));
	R(JNE(arobasevbl1));
arobasevbl2:
	IN(READDBl(eax),READDW(edx));
	R(TEST(8,READDBl(eax),8,(db)8));
	R(JE(arobasevbl2));
	R(LOOP(dffd));
	R(MOV(16,READDW(eax),16,(dw)3));
	R(INT(16));
	R(MOV(32,READDD(edi),32,(dd)1));
	R(MOV(32,READDD(esi),32,(dd)2));
	R(XOR(32,READDD(eax),32,(dd)READDD(eax)));
	R(JMP(exitlabel));
failure:
	R(MOV(8,READDBl(eax),8,(db)1));
exitlabel:
	R(MOV(8,READDBh(eax),8,(db)76));
	R(INT(33));
//PROC affpal
affpal:
	R(PUSHAD);
	R(MOV(32,m.esi.dd.val,32,(((dd)offsetof(struct Mem,pal_jeu)))));
	R(MOV(16,READDW(edx),16,(dw)968));
	R(XOR(8,READDBl(eax),8,(db)READDBl(eax)));
	OUT(READDW(edx),READDBl(eax));
	R(MOV(16,READDW(edx),16,(dw)969));
	R(MOV(16,READDW(ecx),16,(dw)(256*3)));
arobasearobasesaaccvaaaax:
	R(LODSB);
	OUT(READDW(edx),READDBl(eax));
	R(DEC(16,(READDW(ecx))));
	R(JNZ(arobasearobasesaaccvaaaax));
	R(POPAD);
	RET;


	m.executionFinished = 1;
moveToBackGround:
	return (m.executionFinished == 0);
}
void asm2C_printOffsets(unsigned int offset) {
	FILE * file;
	file=fopen("./memoryMap.log", "w");
	fprintf(file, "xox %x (from beg RW) %x:pal_jeu\n",(unsigned int) offsetof(struct Mem,pal_jeu)-offset,(unsigned int) offsetof(struct Mem,pal_jeu));
	fprintf(file, "xox %x (from beg RW) %x:dummy1\n",(unsigned int) offsetof(struct Mem,dummy1)-offset,(unsigned int) offsetof(struct Mem,dummy1));
	fprintf(file, "xox %x (from beg RW) %x:dummy2\n",(unsigned int) offsetof(struct Mem,dummy2)-offset,(unsigned int) offsetof(struct Mem,dummy2));
	fprintf(file, "xox %x (from beg RW) %x:dummy3\n",(unsigned int) offsetof(struct Mem,dummy3)-offset,(unsigned int) offsetof(struct Mem,dummy3));
	fprintf(file, "xox %x (from beg RW) %x:dummy4\n",(unsigned int) offsetof(struct Mem,dummy4)-offset,(unsigned int) offsetof(struct Mem,dummy4));
	fprintf(file, "xox %x (from beg RW) %x:dummy5\n",(unsigned int) offsetof(struct Mem,dummy5)-offset,(unsigned int) offsetof(struct Mem,dummy5));
	fprintf(file, "xox %x (from beg RW) %x:dummy6\n",(unsigned int) offsetof(struct Mem,dummy6)-offset,(unsigned int) offsetof(struct Mem,dummy6));
	fprintf(file, "xox %x (from beg RW) %x:dummy7\n",(unsigned int) offsetof(struct Mem,dummy7)-offset,(unsigned int) offsetof(struct Mem,dummy7));
	fprintf(file, "xox %x (from beg RW) %x:dummy8\n",(unsigned int) offsetof(struct Mem,dummy8)-offset,(unsigned int) offsetof(struct Mem,dummy8));
	fprintf(file, "xox %x (from beg RW) %x:dummy9\n",(unsigned int) offsetof(struct Mem,dummy9)-offset,(unsigned int) offsetof(struct Mem,dummy9));
	fprintf(file, "xox %x (from beg RW) %x:dummy10\n",(unsigned int) offsetof(struct Mem,dummy10)-offset,(unsigned int) offsetof(struct Mem,dummy10));
	fprintf(file, "xox %x (from beg RW) %x:dummy11\n",(unsigned int) offsetof(struct Mem,dummy11)-offset,(unsigned int) offsetof(struct Mem,dummy11));
	fprintf(file, "xox %x (from beg RW) %x:dummy12\n",(unsigned int) offsetof(struct Mem,dummy12)-offset,(unsigned int) offsetof(struct Mem,dummy12));
	fprintf(file, "xox %x (from beg RW) %x:dummy13\n",(unsigned int) offsetof(struct Mem,dummy13)-offset,(unsigned int) offsetof(struct Mem,dummy13));
	fprintf(file, "xox %x (from beg RW) %x:dummy14\n",(unsigned int) offsetof(struct Mem,dummy14)-offset,(unsigned int) offsetof(struct Mem,dummy14));
	fprintf(file, "xox %x (from beg RW) %x:dummy15\n",(unsigned int) offsetof(struct Mem,dummy15)-offset,(unsigned int) offsetof(struct Mem,dummy15));
	fprintf(file, "xox %x (from beg RW) %x:dummy16\n",(unsigned int) offsetof(struct Mem,dummy16)-offset,(unsigned int) offsetof(struct Mem,dummy16));
	fprintf(file, "xox %x (from beg RW) %x:dummy17\n",(unsigned int) offsetof(struct Mem,dummy17)-offset,(unsigned int) offsetof(struct Mem,dummy17));
	fprintf(file, "xox %x (from beg RW) %x:dummy18\n",(unsigned int) offsetof(struct Mem,dummy18)-offset,(unsigned int) offsetof(struct Mem,dummy18));
	fprintf(file, "xox %x (from beg RW) %x:dummy19\n",(unsigned int) offsetof(struct Mem,dummy19)-offset,(unsigned int) offsetof(struct Mem,dummy19));
	fprintf(file, "xox %x (from beg RW) %x:dummy20\n",(unsigned int) offsetof(struct Mem,dummy20)-offset,(unsigned int) offsetof(struct Mem,dummy20));
	fprintf(file, "xox %x (from beg RW) %x:dummy21\n",(unsigned int) offsetof(struct Mem,dummy21)-offset,(unsigned int) offsetof(struct Mem,dummy21));
	fprintf(file, "xox %x (from beg RW) %x:dummy22\n",(unsigned int) offsetof(struct Mem,dummy22)-offset,(unsigned int) offsetof(struct Mem,dummy22));
	fprintf(file, "xox %x (from beg RW) %x:dummy23\n",(unsigned int) offsetof(struct Mem,dummy23)-offset,(unsigned int) offsetof(struct Mem,dummy23));
	fprintf(file, "xox %x (from beg RW) %x:dummy24\n",(unsigned int) offsetof(struct Mem,dummy24)-offset,(unsigned int) offsetof(struct Mem,dummy24));
	fprintf(file, "xox %x (from beg RW) %x:dummy25\n",(unsigned int) offsetof(struct Mem,dummy25)-offset,(unsigned int) offsetof(struct Mem,dummy25));
	fprintf(file, "xox %x (from beg RW) %x:dummy26\n",(unsigned int) offsetof(struct Mem,dummy26)-offset,(unsigned int) offsetof(struct Mem,dummy26));
	fprintf(file, "xox %x (from beg RW) %x:dummy27\n",(unsigned int) offsetof(struct Mem,dummy27)-offset,(unsigned int) offsetof(struct Mem,dummy27));
	fprintf(file, "xox %x (from beg RW) %x:dummy28\n",(unsigned int) offsetof(struct Mem,dummy28)-offset,(unsigned int) offsetof(struct Mem,dummy28));
	fprintf(file, "xox %x (from beg RW) %x:dummy29\n",(unsigned int) offsetof(struct Mem,dummy29)-offset,(unsigned int) offsetof(struct Mem,dummy29));
	fprintf(file, "xox %x (from beg RW) %x:dummy30\n",(unsigned int) offsetof(struct Mem,dummy30)-offset,(unsigned int) offsetof(struct Mem,dummy30));
	fprintf(file, "xox %x (from beg RW) %x:dummy31\n",(unsigned int) offsetof(struct Mem,dummy31)-offset,(unsigned int) offsetof(struct Mem,dummy31));
	fprintf(file, "xox %x (from beg RW) %x:dummy32\n",(unsigned int) offsetof(struct Mem,dummy32)-offset,(unsigned int) offsetof(struct Mem,dummy32));
	fprintf(file, "xox %x (from beg RW) %x:dummy33\n",(unsigned int) offsetof(struct Mem,dummy33)-offset,(unsigned int) offsetof(struct Mem,dummy33));
	fprintf(file, "xox %x (from beg RW) %x:dummy34\n",(unsigned int) offsetof(struct Mem,dummy34)-offset,(unsigned int) offsetof(struct Mem,dummy34));
	fprintf(file, "xox %x (from beg RW) %x:dummy35\n",(unsigned int) offsetof(struct Mem,dummy35)-offset,(unsigned int) offsetof(struct Mem,dummy35));
	fprintf(file, "xox %x (from beg RW) %x:dummy36\n",(unsigned int) offsetof(struct Mem,dummy36)-offset,(unsigned int) offsetof(struct Mem,dummy36));
	fprintf(file, "xox %x (from beg RW) %x:dummy37\n",(unsigned int) offsetof(struct Mem,dummy37)-offset,(unsigned int) offsetof(struct Mem,dummy37));
	fprintf(file, "xox %x (from beg RW) %x:dummy38\n",(unsigned int) offsetof(struct Mem,dummy38)-offset,(unsigned int) offsetof(struct Mem,dummy38));
	fprintf(file, "xox %x (from beg RW) %x:dummy39\n",(unsigned int) offsetof(struct Mem,dummy39)-offset,(unsigned int) offsetof(struct Mem,dummy39));
	fprintf(file, "xox %x (from beg RW) %x:dummy40\n",(unsigned int) offsetof(struct Mem,dummy40)-offset,(unsigned int) offsetof(struct Mem,dummy40));
	fprintf(file, "xox %x (from beg RW) %x:dummy41\n",(unsigned int) offsetof(struct Mem,dummy41)-offset,(unsigned int) offsetof(struct Mem,dummy41));
	fprintf(file, "xox %x (from beg RW) %x:dummy42\n",(unsigned int) offsetof(struct Mem,dummy42)-offset,(unsigned int) offsetof(struct Mem,dummy42));
	fprintf(file, "xox %x (from beg RW) %x:dummy43\n",(unsigned int) offsetof(struct Mem,dummy43)-offset,(unsigned int) offsetof(struct Mem,dummy43));
	fprintf(file, "xox %x (from beg RW) %x:dummy44\n",(unsigned int) offsetof(struct Mem,dummy44)-offset,(unsigned int) offsetof(struct Mem,dummy44));
	fprintf(file, "xox %x (from beg RW) %x:dummy45\n",(unsigned int) offsetof(struct Mem,dummy45)-offset,(unsigned int) offsetof(struct Mem,dummy45));
	fprintf(file, "xox %x (from beg RW) %x:dummy46\n",(unsigned int) offsetof(struct Mem,dummy46)-offset,(unsigned int) offsetof(struct Mem,dummy46));
	fprintf(file, "xox %x (from beg RW) %x:dummy47\n",(unsigned int) offsetof(struct Mem,dummy47)-offset,(unsigned int) offsetof(struct Mem,dummy47));
	fprintf(file, "xox %x (from beg RW) %x:dummy48\n",(unsigned int) offsetof(struct Mem,dummy48)-offset,(unsigned int) offsetof(struct Mem,dummy48));

	fclose(file);
}

FILE * logDebug=NULL;

#define MAX_FMT_SIZE 1024
void log_error(const char *fmt, ...) {
	char formatted_string[MAX_FMT_SIZE];
	va_list argptr;
	va_start(argptr,fmt);
	vsprintf (formatted_string,fmt, argptr);
	va_end(argptr);
#ifdef __LIBRETRO__
	log_cb(RETRO_LOG_ERROR,"%s",formatted_string);
#else
	if (logDebug!=NULL) { fprintf(logDebug,"%s",formatted_string); } else { printf("%s",formatted_string); }
#endif
}
void log_debug(const char *fmt, ...) {
#ifdef DEBUG
	char formatted_string[MAX_FMT_SIZE];
	va_list argptr;
	va_start(argptr,fmt);
	vsprintf (formatted_string,fmt, argptr);
	va_end(argptr);
#ifdef __LIBRETRO__
	log_cb(RETRO_LOG_DEBUG,"%s",formatted_string);
#else
	if (logDebug!=NULL) { fprintf(logDebug,"%s",formatted_string); } else { printf("%s",formatted_string); }
#endif
#endif
}

void log_info(const char *fmt, ...) {
	char formatted_string[MAX_FMT_SIZE];
	va_list argptr;
	va_start(argptr,fmt);
	vsprintf (formatted_string,fmt, argptr);
	va_end(argptr);
#ifdef __LIBRETRO__
	log_cb(RETRO_LOG_INFO,"%s",formatted_string);
#else
	if (logDebug!=NULL) { fprintf(logDebug,"%s",formatted_string); } else { printf("%s",formatted_string); }
#endif
}

void log_debug2(const char *fmt, ...) {
#if DEBUG==2
	char formatted_string[MAX_FMT_SIZE];
	va_list argptr;
	va_start(argptr,fmt);
	vsprintf (formatted_string,fmt, argptr);
	va_end(argptr);
	log_debug(formatted_string);
#endif
}

void checkIfVgaRamEmpty() {
	int i;
	int vgaram_empty = 1;
	for(i = 0; i < VGARAM_SIZE; i++)
		if(m.vgaRam[i])
			vgaram_empty = 0;
	log_debug("vgaram_empty : %s\n", vgaram_empty ? "true" : "false");
	(void) vgaram_empty;
}

void stackDump() {
	log_debug("is_little_endian()=%d\n",m.isLittle);
	log_debug("sizeof(dd)=%zu\n",sizeof(dd));
	log_debug("sizeof(dd *)=%zu\n",sizeof(dd *));
	log_debug("sizeof(dw)=%zu\n",sizeof(dw));
	log_debug("sizeof(db)=%zu\n",sizeof(db));
	log_debug("sizeof(mem)=%zu\n",sizeof(m));
	log_debug("eax: %x\n",READDD(eax));
	hexDump(&m.eax,sizeof(dd));
	log_debug("ebx: %x\n",READDD(ebx));
	log_debug("ecx: %x\n",READDD(ecx));
	log_debug("edx: %x\n",READDD(edx));
	log_debug("ebp: %x\n",READDD(ebp));
	log_debug("cs: %d -> %p\n",READDW(cs),(void *) realAddress(0,cs));
	log_debug("ds: %d -> %p\n",READDW(ds),(void *) realAddress(0,ds));
	log_debug("esi: %x\n",READDD(esi));
	log_debug("ds:esi %p\n",(void *) realAddress(m.esi.dd.val,ds));
	log_debug("es: %d -> %p\n",READDW(es),(void *) realAddress(0,es));
	hexDump(&m.es,sizeof(dd));
	log_debug("edi: %x\n",READDD(edi));
	log_debug("es:edi %p\n",(void *) realAddress(m.edi.dd.val,es));
	hexDump((void *) realAddress(m.edi.dd.val,es),50);
	log_debug("fs: %d -> %p\n",READDW(fs),(void *) realAddress(0,fs));
	log_debug("gs: %d -> %p\n",READDW(gs),(void *) realAddress(0,gs));
	log_debug("adress heap: %p\n",(void *) &m.heap);
	log_debug("adress vgaRam: %p\n",(void *) &m.vgaRam);
	log_debug("first pixels vgaRam: %x\n",*m.vgaRam);
	log_debug("flags: ZF = %d\n",m.ZF);
	log_debug("top stack=%d\n",m.stackPointer);
	checkIfVgaRamEmpty();
}

// thanks to paxdiablo http://stackoverflow.com/users/14860/paxdiablo for the hexDump function
void hexDump (void *addr, int len) {
	int i;
	unsigned char buff[17];
	unsigned char *pc = (unsigned char*)addr;
	(void) buff;
	log_debug ("hexDump %p:\n", addr);

	if (len == 0) {
		log_debug("  ZERO LENGTH\n");
		return;
	}
	if (len < 0) {
		log_debug("  NEGATIVE LENGTH: %i\n",len);
		return;
	}

	// Process every byte in the data.
	for (i = 0; i < len; i++) {
		// Multiple of 16 means new line (with line offset).

		if ((i % 16) == 0) {
			// Just don't print ASCII for the zeroth line.
			if (i != 0)
				log_debug ("  %s\n", buff);

			// Output the offset.
			log_debug ("  %04x ", i);
		}

		// Now the hex code for the specific character.
		log_debug (" %02x", pc[i]);

		// And store a printable ASCII character for later.
		if ((pc[i] < 0x20) || (pc[i] > 0x7e))
			buff[i % 16] = '.';
		else
			buff[i % 16] = pc[i];
		buff[(i % 16) + 1] = '\0';
	}

	// Pad out last line if not exactly 16 characters.
	while ((i % 16) != 0) {
		log_debug ("   ");
		i++;
	}

	// And print the final ASCII bit.
	log_debug ("  %s\n", buff);
}

void asm2C_OUT(int16_t address, int data) {
	static int indexPalette = 0;
	switch(address) {
	case 0x3c8:
		indexPalette=data;
		break;
	case 0x3c9:
		if (indexPalette<768) {
			m.vgaPalette[indexPalette]=data;
			indexPalette++;
		} else {
			log_error("error: indexPalette>767 %d\n",indexPalette);
		}
		break;
	default:
		log_error("unknown OUT %d,%d\n",address, data);
		break;
	}
}

int8_t asm2C_IN(int16_t address) {
	static bool vblTick = 1;
	switch(address) {
	case 0x3DA:
		if (vblTick) {
			vblTick = 0;
			return 0;
		} else {
			vblTick = 1;
			m.jumpToBackGround = 1;
			return 8;
		}
		break;
	default:
		log_error("Unknown IN %d\n",address);
		return 0;
	}
}

bool is_little_endian_real_check() {
	union
	{
		uint16_t x;
		uint8_t y[2];
	} u;

	u.x = 1;
	return u.y[0];
}

/**
 * is_little_endian:
 *
 * Checks if the system is little endian or big-endian.
 *
 * Returns: greater than 0 if little-endian,
 * otherwise big-endian.
 **/
bool is_little_endian()
{
#if defined(__x86_64) || defined(__i386) || defined(_M_IX86) || defined(_M_X64)
	return 1;
#elif defined(MSB_FIRST)
	return 0;
#else
	return is_little_endian_real_check();
#endif
}


void asm2C_init() {
	m.isLittle=is_little_endian();
#ifdef MSB_FIRST
	if (m.isLittle) {
		log_error("Inconsistency: is_little_endian=true and MSB_FIRST defined.\n");
		exit(1);
	}
#endif
	if (m.isLittle!=is_little_endian_real_check()) {
		log_error("Inconsistency in little/big endianess detection. Please check if the Makefile sets MSB_FIRST properly for this architecture.\n");
		exit(1);
	}
	log_debug2("asm2C_init is_little_endian:%d\n",m.isLittle);
}

void asm2C_INT(int a) {
	static FILE * file;
	int i;
	db ah=READDBh(eax);
	db al=READDBl(eax);
	dw ax=READDW(eax);
	dw bx=READDW(ebx);
	dw cx=READDW(ecx);
	dw dx=READDW(edx);
	m.CF = 0;
	log_debug2("asm2C_INT ah=%x al=%x ax=%x bx=%x cx=%x dx=%x\n",ah,al,ax,bx,cx,dx);

	switch(a) {
	case 0x10:
	{
		switch(ax)
		{
		case 0x03: {
			log_debug2("Switch to text mode\n");
			return;
		}
		case 0x13: {
			log_debug2("Switch to VGA\n");
			stackDump();
			return;
		}
		}
		break;
	}
	case 0x21:
		switch(ah)
		{
		case 0x9:
		{
			char * s=(char *) realAddress(m.edx.dd.val,ds);
			for (i=0; s[i]!='$'; i++) {
				printf("%c", s[i]);
			}
			return;
		}
		case 0x2c:
		{
			//MOV(8,8,READDBh(edx),(db)2);
			// TOFIX
			m.edx.dd.val=0x200;
			return;
		}
		case 0x3d:
		{
			char fileName[1000];
			if (m.path!=NULL) {
				sprintf(fileName,"%s/%s",m.path,(const char *) realAddress(m.edx.dd.val, ds));
			} else {
				sprintf(fileName,"%s",(const char *) realAddress(m.edx.dd.val, ds));
			}
			file=fopen(fileName, "rb"); //TOFIX, multiple files support
			log_debug2("Opening file %s -> %p\n",fileName,(void *) file);
			if (file!=NULL) {
				m.eax.dd.val=1; //TOFIX
			} else {
				m.CF = 1;
				log_error("Error opening file %s\n",fileName);
			}
			/*
			   // [Index]AH = 3Dh - "OPEN" - OPEN EXISTING FILE
			   Entry:

			   AL = access and sharing modes
			   DS:DX -> ASCIZ filename
			   Return:

			   CF clear if successful, AX = file handle
			    CF set on error AX = error code (01h,02h,03h,04h,05h,0Ch,56h)
			 */
			// TODO
			return;
		}
		case 0x3e:
		{
			// bx: file handle to close
			//TOFIX
			log_debug2("Closing file. bx:%d\n",bx);
			if (fclose(file))  {
				m.CF = 1;
				perror("Error");
				log_error("Error closing file ? bx:%d %p\n",bx,(void *) file);
			}

			file=NULL;
			return;
		}
		case 0x3f:
		{
			/*
			   [Index]AH = 3Fh - "READ" - READ FROM FILE OR DEVICE

			   Entry:

			   BX = file handle
			   CX = number of bytes to read
			   DS:DX -> buffer for data
			   Return:

			   CF clear if successful - AX = number of bytes actually read (0 if at EOF before call)
			    CF set on error AX = error code (05h,06h)
			 */
			//char grosbuff[100000];
			void * buffer=(db *) realAddress(m.edx.dd.val, ds);
			// log_debug2("Reading ecx=%d cx=%d eds=%x edx=%x -> %p file: %p\n",m.ecx.dd.val,cx,m.ds,m.edx,buffer,(void *)  file);

			if (feof(file)) {
				log_debug2("feof(file)\n");
				m.eax.dd.val=0;
			} else {
				size_t r=fread (buffer,1,cx,file);
				if (r!=cx) {
					perror("Error");
					log_error("r!=cx cx:%d R:%zu \n",cx,r);
					if(!feof(file)) {
						log_error("Error reading ? %d %zu %p\n",cx,r,(void *) file);
						m.CF = 1;
					}
				} else {
					log_debug2("Reading OK %p\n",(void *) file);
				}
				m.eax.dd.val=r;
			}
			/*
			   if (ax!=cx) {
			    log_debug("Error reading ? %d %d\n",ax,cx);
			    m.CF = 1;

			   }
			 */
			return;
		}
		// [Index]AH=42h - "LSEEK" - SET CURRENT FILE POSITION
		case 0x42:
		{
			/*

			   AH=42h - "LSEEK" - SET CURRENT FILE POSITION

			   Entry:

			   AL = origin of move 00h start of file 01h current file position 02h end of file
			   BX = file handle
			   CX:DX = offset from origin of new file position

			 */
			int seek = 0;
			switch(ah) {
			case 0x0:
				seek = SEEK_SET;
				break;
			case 0x1:
				seek = SEEK_CUR;
				break;
			case 0x2:
				seek = SEEK_END;
				break;
			}
			long int offset=(cx<<16)+dx;
			log_debug2("Seeking to offset %ld %d\n",offset,seek);
			if (fseek(file,offset,seek)!=0) {
				log_error("Error seeking\n");
			}
			return;
		}

		case 0x4c:
		{
			stackDump();
			m.jumpToBackGround = 1;
			m.executionFinished = 1;
			m.exitCode = al;
			return;
		}
		default:
			break;
		}
	case 0x31:
		switch(ax)
		{
		case 0x0:
		{
			/*
			   ;2.0 - Function 0000h - Allocate Descriptors:
			   ;--------------------------------------------
			   ;  Allocates one or more descriptors in the client's descriptor table. The
			   ;descriptor(s) allocated must be initialized by the application with other
			   ;function calls.
			   ;In:
			   ;  AX     = 0000h
			   ;  CX     = number of descriptors to allocate
			   ;Out:
			   ;  if successful:
			   ;    carry flag clear
			   ;    AX     = base selector
			 */
			log_debug2("Function 0000h - Allocate %d Descriptors\n",cx);
			if (m.selectorsPointer+cx>=NB_SELECTORS) {
				m.CF = 1;
				log_error("Not enough free selectors (increase NB_SELECTORS)\n");
				return;
			} else {
				m.eax.dd.val = m.selectorsPointer;
				m.selectorsPointer+=cx;
				log_debug2("Return %x\n",m.eax.dd.val);
			}
			return;
		}
		case 0x02:
		{
			/*
			   This function Converts a real mode segment into a protected mode descriptor.
			   BX =    real mode segment
			   Out:
			   if successful:
			   carry flag clear
			   AX =  selector
			   if failed:
			   carry flag set
			 */
			log_debug2("Function 0002h - Converts a real mode segment into a protected mode descriptor real mode segment: %d\n",m.ebx.dd.val);
			if (m.selectorsPointer+1>=NB_SELECTORS) {
				m.CF = 1;
				log_error("Not enough free selectors (increase NB_SELECTORS)\n");
				return;
			}
			// TOFIX ?
			// always return vga adress.
			m.selectors[m.selectorsPointer]=offsetof(struct Mem,vgaRam); // bx;
			m.eax.dd.val=m.selectorsPointer;
			log_debug2("Returns new selector: eax: %d\n",m.eax.dd.val);
			m.selectorsPointer++;

			// Multiple calls for the same real mode segment return the same selector. The returned descriptor should never be modified or freed. <- TOFIX
			return;
		}
		/*
		   ;2.5 - Function 0007h - Set Segment Base Address:
		   ; Sets the 32bit linear base address field in the descriptor for the specified
		   ; segment.
		   ; In:   AX     = 0007h
		   ; BX     = selector
		   ;  CX:DX  = 32bit linear base address of segment
		 */
		case 0x07:
		{
			log_debug2("Function 0007h - Set Segment Base Address: ebx: %x, edx:%x ecx:%x\n",READDD(ebx),READDD(edx),READDD(ecx));
			if (bx>m.selectorsPointer) {
				m.CF = 1;
				log_error("Error: selector number doesnt exist\n");
				return;
			}
			m.selectors[bx]=(READDW(edx)&0xffff)+(READDW(ecx)<<16);
			log_debug2("Address for selector %d: %x\n",bx,m.selectors[bx]);
			return;
		}
		case 0x08:
		{
			/*
			   ;2.6 - Function 0008h - Set Segment Limit:
			   ;-----------------------------------------
			   ;  Sets the limit field in the descriptor for the specified segment.
			   ;  In:
			   ;  AX     = 0008h
			   ;  BX     = selector
			   ;  CX:DX  = 32bit segment limit
			   ;  Out:
			   ;  if successful:
			   ;    carry flag clear
			   ;  if failed:
			   ;    carry flag set
			 */

			// To implement...
			log_debug2("Function 0008h - Set Segment Limit for selector %d (Ignored)\n",bx);
			return;
		}
		case 0x501:
		{
			/*
			   ;2.29 - Function 0501h - Allocate Memory Block:
			   ;In:  AX     = 0501h
			   ;  BX:CX  = size of block in bytes (must be non-zero)
			   ;Out: if successful:
			   ;    carry flag clear
			   ;    BX:CX  = linear address of allocated memory block
			   ;    SI:DI  = memory block handle (used to resize and free block)
			 */
			int32_t nbBlocks=(bx<<16)+cx;
			log_debug2("Function 0501h - Allocate Memory Block: %d bytes\n",nbBlocks);

			if (m.heapPointer+nbBlocks>=HEAP_SIZE) {
				m.CF = 1;
				log_error("Not enough memory (increase HEAP_SIZE)\n");
				exit(1);
				return;
			} else {
				dd a=offsetof(struct Mem,heap)+m.heapPointer;
				m.heapPointer+=nbBlocks;
				{
					log_debug2("New top of heap: %x\n",(dd) offsetof(struct Mem,heap)+m.heapPointer);
				}
				m.ecx.dd.val=a & 0xFFFF;
				m.ebx.dd.val=a >> 16;
				m.edi.dd.val=0; // TOFIX
				m.esi.dd.val=0; // TOFIX
				log_debug2("Return %x ebx:ecx %x:%x\n",a,m.ebx.dd.val,m.ecx.dd.val);
				return;
			}
			break;
		}
		case 0x205: {
			/*
			   fo implement
			   ;2.18 - Function 0204h - Get Protected Mode Interrupt Vector:
			   ;------------------------------------------------------------
			   ;
			   ;  Returns the address of the current protected mode interrupt handler for the
			   ;specified interrupt.
			   ;
			   ;In:
			   ;  AX     = 0204h
			   ;  BL     = interrupt number
			   ;
			   ;Out:
			   ;  always successful:
			   ;    carry flag clear
			   ;    CX:EDX = selector:offset of protected mode interrupt handler

			   ;  AX     = 0204h
			   ;  BL     = interrupt number
			   ;
			   ;Out:
			   ;  always successful:
			   ;    carry flag clear
			   ;    CX:EDX = selector:offset of protected mode interrupt handler
			 */

			return;
		}
		default:
			break;
		}
		break;

	default:
		break;
	}
	m.CF = 1;
	log_error("Error DOSInt 0x%x ah:0x%x al:0x%x: not supported.\n",a,ah,al);
}


#ifdef INCLUDEMAIN
int main() {
	asm2C_init(); stackDump(); while (program()) { }
	return m.exitCode;
}
#endif


